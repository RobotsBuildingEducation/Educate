# Introduction

Backend software engineering is something that a lot of students don't understand. It sometimes feels like some kind of mysterious and cryptic role for smart people. I don't believe that's true, I think that just happens because people don't do a good job of explaining what backend engineering is.

So let's clear that up here. Let's make it easy to understand so we can start thinking about larger systems and techniques.


These are the lessons we're going to cover:

1. Creating users
2. Database foundations
3. Backend Clouds
4. Operating systems & machines

# The Operating System

As always, let's work our way backward. By the end of this lesson, we're going to understand how to define users in applications and how that creates real user experiences. In the next lesson we're going to put together what we've learned to build an app with a step-by-step tutorial. This lesson is going to be pretty conceptual, so let's go into imagination mode. 

So let's highlight one of the key truths about computer science - we use technology to model the real world. Operating systems is kinda where computer science lives. I often suggest to students that they should think about what machines they want to work on before considering a programming language to learn for this reason.  I think people limit the range of where software engineering can exist and this is the concept where you can jump from a macbook to a bitcoin miner to a tesla robot.

So let's step away from computers and let's think about something more relatable, like a kitchen in a restaurant. We don’t have to imagine much other than appreciate all of the moving parts when it comes to creating the final product - your experience with food created and how it's served by the system of operation at the restaurant. 

From a customer’s perspective, you simply order and receive your food but the restaurant will launch a series of protocols to achieve that. Dishes will be washed, inventory will decline, policies and standards will have to be met, messages will be exchanged, things will break. You get the point. A lot of things happen to get your product prepared in a timely manner. The logic of things usually turns out to be pretty common sense and easy! The same is true for computers, which are mostly governed by their own operating system.

So now let's talk to our operating system in a way that you may not be used to. You’ve probably seen this kind of thing in movies or shows or whatever and it’s always this complex matrix of information, but it’s really just a text-based description of what you’re used to seeing with icons and inputs and other user-centric designs. It's a way to communicate with your computers with commands.

You might be wondering why engineers would use such a secretive tool, but it's actually really similar to the difference between ChatGPT generating and Google searching. It's boils down to different forms of usability.

Studying operating systems can have an enormous amount of depth but it's the core of computing that helps you understand where AI fits into machines or why chips get designed to push the boundaries of modern computing. 

I encourage you to really think about what's happening when you're using your devices so that you can appreciate some of the innovation along the way - operating systems these days are really phenomenal in their capacities and it's a good idea to practice appreciation of the little things!



# Backend Engineering

So these terminals or command line interfaces takes us into the world of backend software engineering. One key thing to remember here is that we have to get comfortable letting the machines do the work for us. Let them rip! Remember that computer science is ultimately the science of solving problems and many problems have been solved so that you can program efficiently with powerful modern tools.

Backend engineering is ultimately what gets everything connected. I like to think of it as constructing large pipelines with routes for different needs. Some pipelines may need to have data distributed for researchers and machine learning engineers. Other routes direct data to the right places to help us create smooth user experiences. You’d be surprised how much actually goes into seeing read messages in chat applications or having your account secured when you log in and create and use data. 

But remember, programming models the real world & we primarily use the language of logic to achieve that. It’s really quite wonderful realizing that these large systems that govern all of these operations when you order on Doordash or ship from Amazon ultimately boils down to predictable messages, signals & reactions in & outside of the technology being used. 


Alright, so let's take a deep breath. Please try not to overthink this part, but please do engage in your imagination too. Like most things, it's going to be fairly predictable if you're given guidance. When you're using a command line to communicate with your machine or other external systems, you're going to have your bread-and-butter skills related to that. Cheat sheets people! Use them.

And remember, it's pretty much like having a screen you can click on. You're going to do the equivalent of navigating file sytems, clicking download and install, or saving files to applications. Then if you're curious or a situation has you searching for answers, you can explore more advanced techniques - but for now let's apply one of the golden rules and Keep It Simple. 

# The Database

So that's kinda like level one of building the pipelines. The next part of building pipelines is understanding where the data is stored and how to move it responsibly, like the conveyor belts handling Macbook Pro deliveries around the clock.

There are many different ways to store data, and you may have heard databases using tables with SQL or Excel, or non-relational databases structured with abstractions of key-value pairs. Either way, there's still that fundamental aspect to all of these differences and that's mostly getting used to organizing information using identities and mapping out relationships with those identies.

What that means is that we use identities to refer to and communicate packaged bodies of data. Using basic language, we can describe data inside of a database like this:

"In this collection of users authenticated by Google Sign-In, each user gets uniquely defined by a document of key-value pairs describing the user's profile."

"This table of users connects each user to a table of high scores"

Now again, let's imagine the real world and how data can describe the various identities and relationships using combinations: 

1. What is the identity of the restaurant? CHIPOTLE
2. What is the identity of the city? Chicago
3. What is the identity of the neighborhood? Lincoln Park
5. What is the identity of the order number? A127B
6. What is the identity of the order type? Pick-up

Ffrom a human perspective, you ordered something awfully predictable and truthfully the same truthfully goes for the data perspective. It just takes practice to get a hang of designing relationships between data rather than just using them. In the example above, would you consider allowing a certain maximum at a given time? Is it reasonable for a restaurant to promise handle 250 orders ready at 5:30PM? How could that bottleneck be alleviated? Is there a trend of what kind of ingredient is being ordered? You may be formulating already how data can be a creative exercise.

And if you haven't guessed it yet, you can just about describe anything these days and this is where we can start driving a lot of conversations about studying artificial intelligence, data science or any other number of computational professions. Like lesson one, it's all about organizing data, logic and modeling the world. 



# Creating Users

Creating users is probably one of the most important constructions to understand because it packages our software to creating user experiences. 

In a nutshell, you create an account with a combination of data. So let's say you're using a service that allows you to build banking technology. That service will probably collect your login information, name, address and other financial data to create a unique identity. That unique identity will be converted into these secret keys that you'll get for creating an account and you can use those secret keys to connect your app code to the service. You go through authorization servers or authorization backends to accomplish this verification process. Pipelines people!


And that's all a user is. That's why users have these crazy letter and name combinations like "sKuU1185zZ6agp". Those identities eventually helps point and access data in the right direction. 


# Conclusion

As always, take some time to internalize some of this information. Let your mind explore the concepts and allow yourself to be creative. Don't worry too much about making "mistakes" when you're a beginner - letting yourself create mistakes gives you opportunities to improve. I can totally understand if you found this challenging on the first go because parts are definitely moving now but this ultimately why you get quizzed on these data structures and algorithms for some jobs. If you can theoretically understand those constructions, it can help you pick up the skills to understand large systems operating together too. But really, sometimes you don't need a atomic physicist to build a neighborhood of homes either, sometimes you need creative people for that too, so some people can be frustrated by the practice!

We're going to go throught the process of connecting systems so that we can create an app with users in the next lessons, so that's all folks! See you later.









