# Introduction

Backend software engineering is something that a lot of students don't understand. It sometimes feels like some kind of mysterious and cryptic role for smart people. I don't believe that's true, I think that just happens because people don't do a good job of explaining what backend engineering is.

So let's clear that up here. Let's make it easy to understand so we can start thinking about larger systems and techniques.


These are the lessons we're going to cover:

- Creating users
- Database foundations
- Backend Clouds
- Operating systems & machines



As always, let's work our way backward. By the end of this lesson, we're going to understand how to define users in applications. In the next lesson we're going to put together what we learned to build an app with a step-by-step tutorial. Let's highlight one of the key truths about computer science - we use technology to model the real world. This lesson is going to be pretty conceptual, so let's go into imagination mode. (outfit changes)

Operating systems is kinda where computer science lives. I often suggest to students that they should think about what machines they want to work on before considering a programming language for this reason.  I think people sometimes limit the range of where software engineering can exist, and this is the concept where you can jump from a macbook to a bitcoin miner to a tesla robot.

So let's step away from computers and let's think about something more relatable, like a kitchen in a restaurant. We don’t have to imagine much other than appreciate all of the moving parts that come into order when it comes to creating the final product - your experience with food created and served by the system of operation at the restaurant. 

From a customer’s perspective, you simply receive your food but the restaurant will launch a series of protocols to achieve that. Dishes will be washed, inventory will decline, policies and standards will have to be met, messages will be exchanged, things will break. You get the point. A lot of things happen to get your product prepared in a timely manner. The same is true for computers, which are mostly governed by their own operating system.

So let's talk to our operating system in a way that you're not used to. You’ve probably seen this kind of thing in movies or shows or whatever and it’s always this complex matrix of information, but it’s really just a text-based description of what you’re used to seeing with icons and inputs and other user-centric designs. It's a way to communicate with your computers with commands.

You might be wondering why engineers would use such a secretive tool, but it's actually really similar to the difference between ChatGPT generating answers with AI and having to click through Google to find your search result. It's ultimately just usability choices.

Studying operating systems can has an enormous amount of depth but it's the core of computing that helps you understand where AI fits into machines or how screen readers are implemented to meet various needs. 

I encourage you to really think about what's happening when you're using your devices so that you can appreciate some of the innovation along the way - operating systems these days are really phenomenal in their capacities and it's a good idea to practice appreciation of the little things!

---

So these terminals or command line interfaces takes us into the world of backend software engineering. One key thing to remember here is that we have to get comfortable letting the machines do the work for us. Let them rip! Remember that computer science is ultimately the science of solving problems and many problems have been solved so that you can program efficiently with powerful modern tools.

Backend engineering is ultimately what gets everything connected. I like to think of it as constructing large pipelines for different needs. Some pipelines may be to have data distributed for researchers and machine learning engineers. Other pipelines help us create smooth user experiences on many different devices devices. You’d be surprised how much goes into seeing read messages in chat applications or having your account secured when you log in and create or use data. 

But remember, programming models the real world & we primarily use the language of logic to achieve that. It’s really quite wonderful realizing that these large systems that govern all of these operations when you order on Doordash or ship from Amazon ultimately boils down to predictable messages, signals & reactions in & outside of the technology being used. 

---

Alright, so let's take a deep breath. Please try not to overthink this, but please do engage in your imagination too. Like most things, it's going to be fairly predictable if you're given advanced guidance. When you're using a command line to communicate with your machine or other external systems, you're going to have your bread-and-butter skills related to that. Cheat sheets people! Use them.

And remember, it's pretty much like having a screen you can click on. You're going to do the equivalent of navigating file sytems, clicking download and install, or saving files to applications. Then if you're curious or a situation has you searching for answers, you can explore more advanced techniques - but for now let's apply one of the golden rules and Keep It Simple. 

So that's kinda like level one of building the pipelines. The next part of building pipelines is understanding where the data is stored and how to move it responsibly, like the conveyor belts handling Macbook Pro deliveries around the clock.

There are many different ways to store data, and you may have heard databases using tables with SQL, or non-relational databases structured with abstractions of key-value pairs. Either way, there's still that fundamental aspect to all of these differences and that's mostly getting used to organizing information using identities and mapping out relationships with those identies.

What that means is that we use identities to refer to and communicate bodies of data. Using basic language, we can describe data inside of a database like this:

"In this collection of users authenticated by Google Sign-In, each user gets uniquely defined by a document of key-value pairs describing the user's profile."

"This table of users connects each user to a table of high scores"

Now again, let's imagine the real world and describe the various identities when you order a burrito from Chipotle. Here are the various ways you can describe the data:

1. What is the identity of the restaurant? CMG
2. What is the identity of the city? CHI
3. What is the identity of the neighborhood? LP
5. What is the identity of the order number? A127B

So from a human perspective, you ordered something awfully predictable and truthfully the same goes for the data perspective. It just takes practice to get a hang of designing relationships between data. How does the relationship change if the order is delivery vs. take-out and how does that change a user's experience?

You might have guessed that this kind of data can be used in creative ways. For example, does one neighborhood order more barbacoa than another? How does that affect margins across different states? Are we noticing that customers are creating common flavor profiles? Do most customers order cheese and sour cream and should that give us an idea for future products?

And if you haven't guessed it yet, you can just about describe anything these days and this is where we can start driving a lot of conversations about studying artificial intelligence, data science or any other number of computational professions.

As a matter of fact, let's go back to that idea of having things delivered. It's really easy to visualy how everything has its own unique container and label associated with it and how that entire concept can be translated from the moment you open a shopping website to the moment you open your package.



# Creating Users



# Conclusion

im gnna do this after a round of revision









